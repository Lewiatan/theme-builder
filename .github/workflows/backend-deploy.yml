name: Deploy Backend to VPS

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup PHP 8.3
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: pdo_pgsql, intl, xml, zip, curl, mbstring
          coverage: none

      - name: Validate composer.json
        working-directory: backend
        run: composer validate --strict

      - name: Create test .env file
        working-directory: backend
        run: |
          echo "APP_ENV=test" > .env
          echo "APP_SECRET=test-secret-key" >> .env
          echo "DATABASE_URL=postgresql://test:test@localhost:5432/test" >> .env

      - name: Cache Composer dependencies
        uses: actions/cache@v4
        with:
          path: backend/vendor
          key: composer-${{ runner.os }}-${{ hashFiles('backend/composer.lock') }}
          restore-keys: |
            composer-${{ runner.os }}-

      - name: Install dependencies
        working-directory: backend
        run: composer install --optimize-autoloader --no-interaction --prefer-dist

      - name: Run PHPUnit
        working-directory: backend
        run: |
          if [ -f "vendor/bin/phpunit" ]; then
            vendor/bin/phpunit
          else
            echo "PHPUnit not found, skipping tests"
          fi

  e2e-test:
    needs: test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install Playwright dependencies
        run: npm ci

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps chromium

      - name: Install Playwright system dependencies
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps chromium

      - name: Create .env file for Docker Compose
        run: |
          cat > .env << 'EOF'
          POSTGRES_DB=builder
          POSTGRES_USER=builder
          POSTGRES_PASSWORD=builder
          PGADMIN_DEFAULT_EMAIL=admin@example.com
          PGADMIN_DEFAULT_PASSWORD=admin
          APP_ENV=dev
          APP_SECRET=test-secret-key
          DATABASE_URL=postgresql://builder:builder@postgres:5432/builder?serverVersion=16&charset=utf8
          CORS_ALLOW_ORIGIN=.*
          JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
          JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
          JWT_PASSPHRASE=
          VITE_API_URL=http://localhost:8000
          VITE_DEMO_SHOP_URL=http://localhost:5174
          SKIP_COMPOSER_INSTALL=true
          EOF

          echo "Verifying .env file contents:"
          cat .env

      - name: Cache Docker images
        uses: actions/cache@v4
        id: docker-cache
        with:
          path: /tmp/docker-images
          key: docker-images-${{ runner.os }}-${{ hashFiles('**/Dockerfile', 'docker-compose.yml', '**/package.json', 'backend/composer.json') }}
          restore-keys: |
            docker-images-${{ runner.os }}-

      - name: Load cached Docker images
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          if [ -d "/tmp/docker-images" ]; then
            echo "Loading cached Docker images..."
            for image in /tmp/docker-images/*.tar; do
              if [ -f "$image" ]; then
                docker load -i "$image"
              fi
            done
          fi

      - name: Build and start Docker Compose services
        run: |
          export DOCKER_BUILDKIT=1
          export COMPOSE_DOCKER_CLI_BUILD=1
          docker compose build
          docker compose up -d

      - name: Save Docker images to cache
        if: steps.docker-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/docker-images
          docker images --format "{{.Repository}}:{{.Tag}}" | grep "theme-builder" | while read image; do
            echo "Saving $image..."
            safe_name=$(echo "$image" | tr '/:' '_')
            docker save "$image" -o "/tmp/docker-images/${safe_name}.tar"
          done

      - name: Verify containers are running
        run: |
          echo "Checking container status..."
          docker compose ps

          echo "Waiting for containers to be healthy..."
          sleep 10

          # Check if backend container is running
          if ! docker compose ps backend | grep -q "Up"; then
            echo "ERROR: Backend container is not running!"
            echo "Backend logs:"
            docker compose logs backend
            exit 1
          fi

          echo "All containers are running successfully!"

      - name: Verify environment variables in containers
        run: |
          echo "Checking theme-builder environment variables:"
          docker compose exec -T theme-builder sh -c 'echo "VITE_API_URL=$VITE_API_URL"'
          docker compose exec -T theme-builder sh -c 'echo "VITE_DEMO_SHOP_URL=$VITE_DEMO_SHOP_URL"'

          echo "Checking demo-shop environment variables:"
          docker compose exec -T demo-shop sh -c 'echo "VITE_API_URL=$VITE_API_URL"'
          docker compose exec -T demo-shop sh -c 'echo "SERVER_API_URL=$SERVER_API_URL"'

          echo "Checking backend environment variables:"
          docker compose exec -T backend sh -c 'echo "DATABASE_URL=$DATABASE_URL"'

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "Waiting for PostgreSQL..."
          timeout 30 bash -c 'until docker compose exec -T postgres pg_isready -U builder; do echo "PostgreSQL not ready, waiting..."; sleep 2; done'
          echo "PostgreSQL is ready!"

      - name: Setup backend
        run: |
          echo "Creating .env file inside backend container..."
          docker compose exec -T backend bash -c "
            echo 'APP_ENV=dev' > /var/www/html/.env && \
            echo 'APP_SECRET=test-secret-key' >> /var/www/html/.env && \
            echo 'DATABASE_URL=postgresql://builder:builder@postgres:5432/builder?serverVersion=16&charset=utf8' >> /var/www/html/.env && \
            echo 'DEFAULT_URI=http://localhost:8000' >> /var/www/html/.env && \
            echo 'CORS_ALLOW_ORIGIN=.*' >> /var/www/html/.env && \
            echo 'JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem' >> /var/www/html/.env && \
            echo 'JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem' >> /var/www/html/.env && \
            echo 'JWT_PASSPHRASE=' >> /var/www/html/.env
          "

          echo "Installing composer dependencies (step 1: packages only, no autoloader)..."
          docker compose exec -T backend bash -c "COMPOSER_MEMORY_LIMIT=-1 composer install --no-interaction --no-dev --no-scripts --no-autoloader"

          echo "Generating basic autoloader (step 2: minimal memory usage)..."
          docker compose exec -T backend bash -c "composer dump-autoload --no-dev"

          echo "Verifying Symfony runtime installation..."
          if docker compose exec -T backend test -d vendor/symfony/runtime; then
            echo "✓ Symfony runtime is installed!"
          else
            echo "✗ FAILED: Symfony runtime still missing!"
            echo "Listing vendor/symfony directory:"
            docker compose exec -T backend ls -la vendor/symfony/ || echo "vendor/symfony directory doesn't exist"
            exit 1
          fi

          echo "Warming up Symfony cache..."
          docker compose exec -T backend php bin/console cache:clear --env=dev
          docker compose exec -T backend php bin/console cache:warmup --env=dev

          echo "Generating JWT keypair..."
          docker compose exec -T backend php bin/console lexik:jwt:generate-keypair --skip-if-exists
          echo "JWT keypair generated successfully!"

          echo "Running database migrations..."
          docker compose exec -T backend vendor/bin/phinx migrate -e development || echo "Migrations already applied or failed"
          docker compose exec -T backend vendor/bin/phinx seed:run -e development || echo "Seeds already applied or failed"

      - name: Wait for services to be ready
        run: |
          echo "Waiting for backend API health endpoint..."
          timeout 120 bash -c 'until curl -f http://localhost:8000/health 2>/dev/null; do echo "Backend health endpoint not ready, waiting..."; sleep 3; done' && echo "Backend health endpoint is ready!" || (echo "Backend health check timed out" && docker compose logs backend nginx && exit 1)

          echo "Testing backend API auth endpoint..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@test.com","password":"test"}')
          echo "Auth endpoint returned HTTP $HTTP_CODE"
          if [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "000" ]; then
            echo "Backend API is not responding correctly!"
            echo "Backend logs:"
            docker compose logs backend
            echo "Nginx logs:"
            docker compose logs nginx
            exit 1
          fi
          echo "Backend API is responding!"

          echo "Waiting for theme-builder to be ready..."
          timeout 60 bash -c 'until curl -f http://localhost:5173 2>/dev/null; do echo "Theme-builder not ready, waiting..."; sleep 2; done' && echo "Theme-builder is ready!" || (echo "Theme-builder timed out" && exit 1)

          echo "Waiting for demo-shop to be ready..."
          timeout 60 bash -c 'until curl -f http://localhost:5174 2>/dev/null; do echo "Demo-shop not ready, waiting..."; sleep 2; done' && echo "Demo-shop is ready!" || (echo "Demo-shop timed out" && exit 1)

          echo "All services are ready!"

      - name: Run Playwright E2E tests
        run: npx playwright test

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Stop Docker Compose
        if: always()
        run: docker compose down

  deploy:
    needs: e2e-test
    runs-on: ubuntu-latest
    environment: production

    env:
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_PORT: ${{ secrets.VPS_PORT }}
      VPS_USERNAME: ${{ secrets.VPS_USERNAME }}
      VPS_DEPLOY_PATH: ${{ secrets.VPS_DEPLOY_PATH }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      APP_SECRET: ${{ secrets.APP_SECRET }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.VPS_PORT }} -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy files via rsync
        run: |
          rsync -avz --delete --force \
            --exclude='.git' \
            --exclude='var/' \
            --exclude='vendor/' \
            --exclude='.env' \
            --exclude='.env.local' \
            --exclude='.env.test' \
            --exclude='docker/' \
            --exclude='docker-compose.yml' \
            --exclude='Dockerfile' \
            -e "ssh -i ~/.ssh/deploy_key -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no" \
            backend/ ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }}:${{ secrets.VPS_DEPLOY_PATH }}/

      - name: Post-deployment tasks
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.VPS_PORT }} -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            cd ${{ secrets.VPS_DEPLOY_PATH }}

            # Update environment variables
            echo "APP_ENV=prod" > .env
            echo "APP_SECRET=${{ secrets.APP_SECRET }}" >> .env
            echo "DATABASE_URL=\"${{ secrets.DATABASE_URL }}\"" >> .env
            echo "DEFAULT_URI=https://tbapi.bieda.it" >> .env
            echo "CORS_ALLOW_ORIGIN=^https?://(localhost|tbapi\.bieda\.it|.*\.bieda\.it|demo-shop-two\.vercel\.app|theme-builder-two\.vercel\.app)(:[0-9]+)?$" >> .env
            echo "JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem" >> .env
            echo "JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem" >> .env
            echo "JWT_PASSPHRASE=" >> .env

            # Install dependencies
            composer install --no-dev --optimize-autoloader --no-interaction

            # Generate JWT keys if they don't exist
            if [ ! -f config/jwt/private.pem ]; then
              php bin/console lexik:jwt:generate-keypair --skip-if-exists
              chgrp www-data config/jwt/*.pem 2>/dev/null || true
              chmod 640 config/jwt/private.pem 2>/dev/null || true
              chmod 644 config/jwt/public.pem 2>/dev/null || true
              echo "JWT keys generated"
            else
              echo "JWT keys already exist, skipping generation"
            fi

            # Parse DATABASE_URL and export as PHINX_* environment variables
            DB_URL="${{ secrets.DATABASE_URL }}"
            export PHINX_DBUSER=$(echo $DB_URL | sed -n 's|.*://\([^:]*\):.*|\1|p')
            export PHINX_DBPASS=$(echo $DB_URL | sed -n 's|.*://[^:]*:\([^@]*\)@.*|\1|p')
            export PHINX_DBHOST=$(echo $DB_URL | sed -n 's|.*@\([^:]*\):.*|\1|p')
            export PHINX_DBPORT=$(echo $DB_URL | sed -n 's|.*:\([0-9]*\)/.*|\1|p')
            export PHINX_DBNAME=$(echo $DB_URL | sed -n 's|.*/\([^?]*\).*|\1|p')

            # Run database migrations
            vendor/bin/phinx migrate -e production
            vendor/bin/phinx seed:run -e production

            # Clear and warm up Symfony cache
            php bin/console cache:clear --env=prod --no-warmup
            php bin/console cache:warmup --env=prod

            # Set proper permissions
            chgrp -R www-data var/ 2>/dev/null || true
            chmod -R 775 var/ 2>/dev/null || true
            chmod -R g+s var/ 2>/dev/null || true
            chmod 644 config/jwt/public.pem 2>/dev/null || true
            chmod 640 config/jwt/private.pem 2>/dev/null || true
            chgrp www-data config/jwt/*.pem 2>/dev/null || true

            echo "Deployment completed successfully!"
          ENDSSH

      - name: Deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Backend deployed successfully to production!"
          else
            echo "❌ Deployment failed! Check the logs above."
          fi
