# Database Schema - E-commerce Theme Builder

## 1. Tables

### 1.1 users

This table is managed by Supabase Auth

### 1.2. shops
Primary organizational entity representing a user's shop.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique shop identifier |
| user_id | UUID | NOT NULL, UNIQUE, REFERENCES auth.users(id) ON DELETE CASCADE | Owner reference (one shop per user) |
| name | VARCHAR(60) | NOT NULL | Shop name |
| theme_settings | JSONB | NOT NULL, DEFAULT '{}' | Theme configuration (colors, fonts) |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Shop creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last modification timestamp |

**Constraints:**
- PRIMARY KEY (id)
- UNIQUE (user_id)
- FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE

---

### 1.3. pages
Stores page layouts for each shop.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique page identifier |
| shop_id | UUID | NOT NULL, REFERENCES shops(id) ON DELETE CASCADE | Shop ownership reference |
| type | page_type_enum | NOT NULL | Page type (home, catalog, product, contact) |
| layout | JSONB | NOT NULL, DEFAULT '[]' | Component array with structure |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Page creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last modification timestamp |

**Constraints:**
- PRIMARY KEY (id)
- UNIQUE (shop_id, type)
- FOREIGN KEY (shop_id) REFERENCES shops(id) ON DELETE CASCADE

**Layout JSONB Structure:**
```json
[
  {
    "id": "uuid-string",
    "type": "component-type-name",
    "variant": "variant-name",
    "settings": {
      "key": "value"
    }
  }
]
```

---

### 1.4. demo_categories
Static product categories shared across all shops.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Category identifier |
| name | VARCHAR(255) | NOT NULL | Category name |

**Constraints:**
- PRIMARY KEY (id)

**Ordering:**
- Default ordering: alphabetical by name (handled in queries)

---

### 1.5. demo_products
Static product catalog shared across all shops.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Product identifier |
| category_id | INTEGER | NOT NULL, REFERENCES demo_categories(id) | Category reference |
| name | VARCHAR(255) | NOT NULL | Product name |
| description | TEXT | NOT NULL | Product description |
| price | INTEGER | NOT NULL | Price in cents (e.g., 1999 = $19.99) |
| sale_price | INTEGER | NULL | Sale price in cents (NULL if not on sale) |
| image_thumbnail | VARCHAR(255) | NOT NULL | Thumbnail image URL |
| image_medium | VARCHAR(255) | NOT NULL | Medium size image URL |
| image_large | VARCHAR(255) | NOT NULL | Large size image URL |

**Constraints:**
- PRIMARY KEY (id)
- FOREIGN KEY (category_id) REFERENCES demo_categories(id)

**Ordering:**
- Default ordering: alphabetical by name (handled in queries)

---

## 2. Enums

### 2.1. page_type_enum
Defines valid page types.

```sql
CREATE TYPE page_type_enum AS ENUM ('home', 'catalog', 'product', 'contact');
```

---

## 3. Relationships

### 3.1. User to Shop
- **Cardinality:** One-to-One
- **Direction:** auth.users → shops
- **Implementation:** shops.user_id (UNIQUE) REFERENCES auth.users(id)
- **Cascade:** ON DELETE CASCADE (deleting user deletes shop)

### 3.2. Shop to Pages
- **Cardinality:** One-to-Many
- **Direction:** shops → pages
- **Implementation:** pages.shop_id REFERENCES shops(id)
- **Cascade:** ON DELETE CASCADE (deleting shop deletes all pages)

### 3.3. Category to Products
- **Cardinality:** One-to-Many
- **Direction:** demo_categories → demo_products
- **Implementation:** demo_products.category_id REFERENCES demo_categories(id)
- **Cascade:** None (static data)

---

## 4. Indexes

### 4.1. shops table
```sql
CREATE UNIQUE INDEX idx_shops_user_id ON shops(user_id);
```
- **Purpose:** Fast user shop lookup and enforce one shop per user
- **Type:** Unique B-tree index

### 4.2. pages table
```sql
CREATE UNIQUE INDEX idx_pages_shop_type ON pages(shop_id, type);
```
- **Purpose:** Fast page lookups by shop and type, enforce uniqueness constraint
- **Type:** Unique composite B-tree index

### 4.3. demo_products table
```sql
CREATE INDEX idx_demo_products_category_id ON demo_products(category_id);
```
- **Purpose:** Fast filtering of products by category
- **Type:** B-tree index

---

## 5. Row-Level Security (RLS) Policies

### 5.1. shops table
**Enable RLS:**
```sql
ALTER TABLE shops ENABLE ROW LEVEL SECURITY;
```

**Policy: shops_select_policy**
```sql
CREATE POLICY shops_select_policy ON shops
  FOR SELECT
  USING (user_id = auth.uid());
```
- **Operation:** SELECT
- **Rule:** Users can only view their own shop

**Policy: shops_insert_policy**
```sql
CREATE POLICY shops_insert_policy ON shops
  FOR INSERT
  WITH CHECK (user_id = auth.uid());
```
- **Operation:** INSERT
- **Rule:** Users can only create shops for themselves

**Policy: shops_update_policy**
```sql
CREATE POLICY shops_update_policy ON shops
  FOR UPDATE
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());
```
- **Operation:** UPDATE
- **Rule:** Users can only update their own shop

**Policy: shops_delete_policy**
```sql
CREATE POLICY shops_delete_policy ON shops
  FOR DELETE
  USING (user_id = auth.uid());
```
- **Operation:** DELETE
- **Rule:** Users can only delete their own shop

---

### 5.2. pages table
**Enable RLS:**
```sql
ALTER TABLE pages ENABLE ROW LEVEL SECURITY;
```

**Policy: pages_select_policy**
```sql
CREATE POLICY pages_select_policy ON pages
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM shops
      WHERE shops.id = pages.shop_id
      AND shops.user_id = auth.uid()
    )
  );
```
- **Operation:** SELECT
- **Rule:** Users can view pages belonging to their shop

**Policy: pages_insert_policy**
```sql
CREATE POLICY pages_insert_policy ON pages
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM shops
      WHERE shops.id = pages.shop_id
      AND shops.user_id = auth.uid()
    )
  );
```
- **Operation:** INSERT
- **Rule:** Users can create pages only for their shop

**Policy: pages_update_policy**
```sql
CREATE POLICY pages_update_policy ON pages
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM shops
      WHERE shops.id = pages.shop_id
      AND shops.user_id = auth.uid()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM shops
      WHERE shops.id = pages.shop_id
      AND shops.user_id = auth.uid()
    )
  );
```
- **Operation:** UPDATE
- **Rule:** Users can update pages belonging to their shop

**Policy: pages_delete_policy**
```sql
CREATE POLICY pages_delete_policy ON pages
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM shops
      WHERE shops.id = pages.shop_id
      AND shops.user_id = auth.uid()
    )
  );
```
- **Operation:** DELETE
- **Rule:** Users can delete pages belonging to their shop

---

### 5.3. demo_categories table
**No RLS policies** - Shared static data accessible to all authenticated users

---

### 5.4. demo_products table
**No RLS policies** - Shared static data accessible to all authenticated users

---

## 6. Triggers

### 6.1. Automatic updated_at timestamp
Create a reusable function and apply it to all tables with updated_at column.

**Function:**
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**Triggers:**
```sql
CREATE TRIGGER update_shops_updated_at
  BEFORE UPDATE ON shops
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_pages_updated_at
  BEFORE UPDATE ON pages
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

---

## 7. Design Decisions and Notes

### 7.1. JSON Storage Strategy
- **Page layouts** stored as JSONB arrays for flexibility and atomic updates
- **Theme settings** stored as JSONB for schema evolution without migrations
- **Component settings** embedded in layout JSON for simplicity
- No database-level validation of JSON structure (handled in application)
- No GIN indexes on JSONB for MVP (premature optimization)

### 7.2. Authentication Integration
- Uses Supabase Auth's built-in `auth.users` table
- Foreign key from `shops.user_id` to `auth.users.id`
- RLS policies leverage `auth.uid()` function for access control

### 7.3. Data Isolation
- Complete user data isolation through shop ownership
- RLS ensures no cross-user data leakage
- Demo data shared across all shops (no RLS)

### 7.4. Cascade Behavior
Two-level cascade deletion:
1. **User deleted** → Shop deleted (CASCADE)
2. **Shop deleted** → All pages deleted (CASCADE)
3. Demo data has no cascades (static reference data)

### 7.5. Constraints Enforcement
- **One shop per user:** UNIQUE constraint on `shops.user_id`
- **One page of each type per shop:** UNIQUE constraint on `pages(shop_id, type)`
- **Page type validation:** Enforced via enum `page_type_enum`
- **Foreign key integrity:** All relationships use FK constraints

### 7.6. Performance Considerations
- Minimal indexing strategy for MVP
- Three indexes total: user_id on shops, composite on pages, category_id on demo_products
- JSONB operations expected to be fast enough for MVP workload
- No materialized views or partitioning needed at this scale

### 7.7. Migration Execution Order
Recommended order for creating schema:
1. Create enum: `page_type_enum`
2. Create tables: `shops` → `pages`, `demo_categories` → `demo_products`
3. Create indexes on all tables
4. Create trigger function: `update_updated_at_column()`
5. Create triggers on `shops` and `pages`
6. Enable RLS on `shops` and `pages`
7. Create RLS policies for `shops` and `pages`

### 7.8. Application Responsibilities
The following are NOT handled at database level:
- Component template definitions
- Default page layouts for new users
- JSONB structure validation
- Theme settings schema validation
- Initial shop/page creation on registration
- Image URL format validation
- Demo data seeding

### 7.9. Future Considerations
- JSON storage allows adding new component types without schema changes
- Shop-centric model can support multi-shop per user in future
- Can add media library table later without breaking image URL references
- Can introduce audit/versioning tables as separate layer
- Can add full-text search indexes when needed
