-- ============================================================================
-- Migration: Initial Schema for E-commerce Theme Builder
-- Created: 2025-10-11 13:58:03 UTC
-- Description: Creates complete database schema including shops, pages, 
--              demo products/categories, RLS policies, indexes, and triggers
-- ============================================================================
-- Affected Objects:
--   - Enum: page_type_enum
--   - Tables: shops, pages, demo_categories, demo_products
--   - Indexes: idx_shops_user_id, idx_pages_shop_type, idx_demo_products_category_id
--   - Function: update_updated_at_column()
--   - Triggers: update_shops_updated_at, update_pages_updated_at
--   - RLS: policies for shops and pages tables
-- ============================================================================

-- ============================================================================
-- SECTION 1: ENUMS
-- ============================================================================

-- create enum for valid page types
-- this constrains pages to only four allowed types
create type page_type_enum as enum ('home', 'catalog', 'product', 'contact');

-- ============================================================================
-- SECTION 2: TABLES
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Table: shops
-- Purpose: Primary organizational entity representing a user's shop
-- Ownership: One shop per user (enforced by unique constraint)
-- Cascade: Deletes all pages when shop is deleted
-- ----------------------------------------------------------------------------
create table shops (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null unique references auth.users(id) on delete cascade,
  name varchar(60) not null,
  theme_settings jsonb not null default '{}',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table shops is 'Primary organizational entity representing a user''s shop. One shop per user.';
comment on column shops.user_id is 'Owner reference - each user can have only one shop (enforced by UNIQUE constraint)';
comment on column shops.theme_settings is 'JSONB storage for theme configuration including colors, fonts, etc.';

-- ----------------------------------------------------------------------------
-- Table: pages
-- Purpose: Stores page layouts for each shop with component definitions
-- Uniqueness: One page of each type per shop
-- Layout: JSONB array of component objects with id, type, variant, settings
-- ----------------------------------------------------------------------------
create table pages (
  id uuid primary key default gen_random_uuid(),
  shop_id uuid not null references shops(id) on delete cascade,
  type page_type_enum not null,
  layout jsonb not null default '[]',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(shop_id, type)
);

comment on table pages is 'Stores page layouts for each shop. Each shop can have one page of each type.';
comment on column pages.type is 'Page type constrained to: home, catalog, product, contact';
comment on column pages.layout is 'JSONB array of components with structure: [{id, type, variant, settings}]';
comment on constraint pages_shop_id_type_key on pages is 'Ensures one page of each type per shop';

-- ----------------------------------------------------------------------------
-- Table: demo_categories
-- Purpose: Static product categories shared across all shops
-- Access: Read-only for all authenticated users (no RLS restrictions)
-- Ordering: Alphabetical by name (handled in application queries)
-- ----------------------------------------------------------------------------
create table demo_categories (
  id integer primary key generated by default as identity,
  name varchar(255) not null
);

comment on table demo_categories is 'Static product categories shared across all shops. No RLS - accessible to all users.';

-- ----------------------------------------------------------------------------
-- Table: demo_products
-- Purpose: Static product catalog shared across all shops
-- Access: Read-only for all authenticated users (no RLS restrictions)
-- Pricing: Stored in cents (e.g., 1999 = $19.99)
-- Images: Three size variants for responsive display
-- ----------------------------------------------------------------------------
create table demo_products (
  id integer primary key generated by default as identity,
  category_id integer not null references demo_categories(id),
  name varchar(255) not null,
  description text not null,
  price integer not null,
  sale_price integer null,
  image_thumbnail varchar(255) not null,
  image_medium varchar(255) not null,
  image_large varchar(255) not null
);

comment on table demo_products is 'Static product catalog shared across all shops. No RLS - accessible to all users.';
comment on column demo_products.price is 'Price in cents (e.g., 1999 = $19.99)';
comment on column demo_products.sale_price is 'Sale price in cents. NULL if not on sale.';

-- ============================================================================
-- SECTION 3: INDEXES
-- ============================================================================

-- index for fast user shop lookup and enforce one shop per user
create unique index idx_shops_user_id on shops(user_id);

-- composite index for fast page lookups by shop and type, enforces uniqueness
create unique index idx_pages_shop_type on pages(shop_id, type);

-- index for filtering products by category
create index idx_demo_products_category_id on demo_products(category_id);

-- ============================================================================
-- SECTION 4: TRIGGERS AND FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Function: update_updated_at_column
-- Purpose: Automatically update updated_at timestamp on row updates
-- Usage: Applied to shops and pages tables via triggers
-- ----------------------------------------------------------------------------
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

comment on function update_updated_at_column is 'Automatically updates updated_at column to current timestamp on UPDATE operations';

-- trigger for shops table to auto-update updated_at column
create trigger update_shops_updated_at
  before update on shops
  for each row
  execute function update_updated_at_column();

-- trigger for pages table to auto-update updated_at column
create trigger update_pages_updated_at
  before update on pages
  for each row
  execute function update_updated_at_column();

-- ============================================================================
-- SECTION 5: ROW LEVEL SECURITY (RLS)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- RLS for shops table
-- Security Model: Users can only access their own shop
-- Policies: Granular policies for each operation (select, insert, update, delete)
-- ----------------------------------------------------------------------------

-- enable rls on shops table
alter table shops enable row level security;

-- policy: users can view only their own shop
create policy shops_select_policy on shops
  for select
  using (user_id = auth.uid());

comment on policy shops_select_policy on shops is 'Users can only view their own shop';

-- policy: users can create shops only for themselves
create policy shops_insert_policy on shops
  for insert
  with check (user_id = auth.uid());

comment on policy shops_insert_policy on shops is 'Users can only create shops for themselves (user_id must match auth.uid())';

-- policy: users can update only their own shop
create policy shops_update_policy on shops
  for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

comment on policy shops_update_policy on shops is 'Users can only update their own shop';

-- policy: users can delete only their own shop
-- WARNING: this is a destructive operation that will cascade to pages table
create policy shops_delete_policy on shops
  for delete
  using (user_id = auth.uid());

comment on policy shops_delete_policy on shops is 'Users can only delete their own shop. WARNING: Cascades to pages table.';

-- ----------------------------------------------------------------------------
-- RLS for pages table
-- Security Model: Users can only access pages belonging to their shop
-- Implementation: Subquery checks shop ownership via shops.user_id
-- Policies: Granular policies for each operation (select, insert, update, delete)
-- ----------------------------------------------------------------------------

-- enable rls on pages table
alter table pages enable row level security;

-- policy: users can view pages belonging to their shop
create policy pages_select_policy on pages
  for select
  using (
    exists (
      select 1 from shops
      where shops.id = pages.shop_id
      and shops.user_id = auth.uid()
    )
  );

comment on policy pages_select_policy on pages is 'Users can view pages belonging to their shop (verified via shops.user_id)';

-- policy: users can create pages only for their shop
create policy pages_insert_policy on pages
  for insert
  with check (
    exists (
      select 1 from shops
      where shops.id = pages.shop_id
      and shops.user_id = auth.uid()
    )
  );

comment on policy pages_insert_policy on pages is 'Users can create pages only for their shop (verified via shops.user_id)';

-- policy: users can update pages belonging to their shop
create policy pages_update_policy on pages
  for update
  using (
    exists (
      select 1 from shops
      where shops.id = pages.shop_id
      and shops.user_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from shops
      where shops.id = pages.shop_id
      and shops.user_id = auth.uid()
    )
  );

comment on policy pages_update_policy on pages is 'Users can update pages belonging to their shop (verified via shops.user_id)';

-- policy: users can delete pages belonging to their shop
create policy pages_delete_policy on pages
  for delete
  using (
    exists (
      select 1 from shops
      where shops.id = pages.shop_id
      and shops.user_id = auth.uid()
    )
  );

comment on policy pages_delete_policy on pages is 'Users can delete pages belonging to their shop (verified via shops.user_id)';

-- ============================================================================
-- MIGRATION NOTES
-- ============================================================================
-- 
-- NO RLS ON DEMO TABLES:
--   - demo_categories and demo_products have no RLS policies
--   - These are shared static data accessible to all authenticated users
--   - Application should handle read-only access control
--
-- CASCADE BEHAVIOR:
--   1. User deleted → Shop deleted (CASCADE)
--   2. Shop deleted → All pages deleted (CASCADE)
--   3. Demo data has no cascades (static reference data)
--
-- APPLICATION RESPONSIBILITIES:
--   - Component template definitions
--   - Default page layouts for new shops
--   - JSONB structure validation
--   - Theme settings schema validation
--   - Initial shop/page creation on user registration
--   - Image URL format validation
--   - Demo data seeding
--
-- PERFORMANCE CONSIDERATIONS:
--   - Minimal indexing strategy for MVP
--   - No GIN indexes on JSONB columns (premature optimization)
--   - JSONB operations expected to be fast enough for MVP workload
--
-- ============================================================================
