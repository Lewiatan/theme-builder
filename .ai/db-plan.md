# Database Schema - E-commerce Theme Builder

## 1. Tables

### 1.1. users
Stores user authentication and account information.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique user identifier |
| email | VARCHAR(255) | NOT NULL, UNIQUE | User email address |
| password | VARCHAR(255) | NOT NULL | Hashed password (bcrypt/argon2) |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Account creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last modification timestamp |

**Constraints:**
- PRIMARY KEY (id)
- UNIQUE (email)

**Notes:**
- Password hashing handled by Symfony PasswordHasher
- Authentication managed via JWT tokens (LexikJWTAuthenticationBundle)

### 1.2. shops
Primary organizational entity representing a user's shop.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique shop identifier |
| user_id | UUID | NOT NULL, UNIQUE, REFERENCES users(id) ON DELETE CASCADE | Owner reference (one shop per user) |
| name | VARCHAR(60) | NOT NULL | Shop name |
| theme_settings | JSONB | NOT NULL, DEFAULT '{}' | Theme configuration (colors, fonts) |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Shop creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last modification timestamp |

**Constraints:**
- PRIMARY KEY (id)
- UNIQUE (user_id)
- FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE

---

### 1.3. pages
Stores page layouts for each shop.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique page identifier |
| shop_id | UUID | NOT NULL, REFERENCES shops(id) ON DELETE CASCADE | Shop ownership reference |
| type | page_type_enum | NOT NULL | Page type (home, catalog, product, contact) |
| layout | JSONB | NOT NULL, DEFAULT '[]' | Component array with structure |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Page creation timestamp |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() | Last modification timestamp |

**Constraints:**
- PRIMARY KEY (id)
- UNIQUE (shop_id, type)
- FOREIGN KEY (shop_id) REFERENCES shops(id) ON DELETE CASCADE

**Layout JSONB Structure:**
```json
[
  {
    "id": "uuid-string",
    "type": "component-type-name",
    "variant": "variant-name",
    "settings": {
      "key": "value"
    }
  }
]
```

---

### 1.4. demo_categories
Static product categories shared across all shops.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Category identifier |
| name | VARCHAR(255) | NOT NULL | Category name |

**Constraints:**
- PRIMARY KEY (id)

**Ordering:**
- Default ordering: alphabetical by name (handled in queries)

---

### 1.5. demo_products
Static product catalog shared across all shops.

| Column | Data Type | Constraints | Description |
|--------|-----------|-------------|-------------|
| id | INTEGER | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Product identifier |
| category_id | INTEGER | NOT NULL, REFERENCES demo_categories(id) | Category reference |
| name | VARCHAR(255) | NOT NULL | Product name |
| description | TEXT | NOT NULL | Product description |
| price | INTEGER | NOT NULL | Price in cents (e.g., 1999 = $19.99) |
| sale_price | INTEGER | NULL | Sale price in cents (NULL if not on sale) |
| image_thumbnail | VARCHAR(255) | NOT NULL | Thumbnail image URL |
| image_medium | VARCHAR(255) | NOT NULL | Medium size image URL |
| image_large | VARCHAR(255) | NOT NULL | Large size image URL |

**Constraints:**
- PRIMARY KEY (id)
- FOREIGN KEY (category_id) REFERENCES demo_categories(id)

**Ordering:**
- Default ordering: alphabetical by name (handled in queries)

---

## 2. Enums

### 2.1. page_type_enum
Defines valid page types.

```sql
CREATE TYPE page_type_enum AS ENUM ('home', 'catalog', 'product', 'contact');
```

---

## 3. Relationships

### 3.1. User to Shop
- **Cardinality:** One-to-One
- **Direction:** users → shops
- **Implementation:** shops.user_id (UNIQUE) REFERENCES users(id)
- **Cascade:** ON DELETE CASCADE (deleting user deletes shop)

### 3.2. Shop to Pages
- **Cardinality:** One-to-Many
- **Direction:** shops → pages
- **Implementation:** pages.shop_id REFERENCES shops(id)
- **Cascade:** ON DELETE CASCADE (deleting shop deletes all pages)

### 3.3. Category to Products
- **Cardinality:** One-to-Many
- **Direction:** demo_categories → demo_products
- **Implementation:** demo_products.category_id REFERENCES demo_categories(id)
- **Cascade:** None (static data)

---

## 4. Indexes

### 4.1. users table
```sql
CREATE UNIQUE INDEX idx_users_email ON users(email);
```
- **Purpose:** Fast email lookup for authentication and enforce uniqueness
- **Type:** Unique B-tree index

### 4.2. shops table
```sql
CREATE UNIQUE INDEX idx_shops_user_id ON shops(user_id);
```
- **Purpose:** Fast user shop lookup and enforce one shop per user
- **Type:** Unique B-tree index

### 4.3. pages table
```sql
CREATE UNIQUE INDEX idx_pages_shop_type ON pages(shop_id, type);
```
- **Purpose:** Fast page lookups by shop and type, enforce uniqueness constraint
- **Type:** Unique composite B-tree index

### 4.4. demo_products table
```sql
CREATE INDEX idx_demo_products_category_id ON demo_products(category_id);
```
- **Purpose:** Fast filtering of products by category
- **Type:** B-tree index

---

## 5. Design Decisions and Notes

### 5.1. JSON Storage Strategy
- **Page layouts** stored as JSONB arrays for flexibility and atomic updates
- **Theme settings** stored as JSONB for schema evolution without migrations
- **Component settings** embedded in layout JSON for simplicity
- No database-level validation of JSON structure (handled in application)
- No GIN indexes on JSONB for MVP (premature optimization)

### 5.2. Authentication Integration
- JWT-based authentication managed by Symfony (LexikJWTAuthenticationBundle)
- Password hashing handled by Symfony PasswordHasher (bcrypt/argon2)
- Authorization enforced at API level via Symfony Security component
- Repository-level filtering ensures users can only access their own data

### 5.3. Data Isolation
- Complete user data isolation through shop ownership validation in API
- Foreign key constraints ensure referential integrity
- Demo data shared across all shops (publicly readable via API)

### 5.4. Timestamp Management
- `created_at` and `updated_at` timestamps managed by Symfony API layer
- Doctrine lifecycle callbacks handle automatic timestamp updates
- No database triggers required

### 5.5. Cascade Behavior
Two-level cascade deletion:
1. **User deleted** → Shop deleted (CASCADE)
2. **Shop deleted** → All pages deleted (CASCADE)
3. Demo data has no cascades (static reference data)

### 5.6. Constraints Enforcement
- **One shop per user:** UNIQUE constraint on `shops.user_id`
- **One page of each type per shop:** UNIQUE constraint on `pages(shop_id, type)`
- **Page type validation:** Enforced via enum `page_type_enum`
- **Foreign key integrity:** All relationships use FK constraints

### 5.7. Performance Considerations
- Minimal indexing strategy for MVP
- Four indexes total: email on users, user_id on shops, composite on pages, category_id on demo_products
- JSONB operations expected to be fast enough for MVP workload
- No materialized views or partitioning needed at this scale

### 5.8. Migration Execution Order
Recommended order for creating schema:
1. Create enum: `page_type_enum`
2. Create tables: `users` → `shops` → `pages`, `demo_categories` → `demo_products`
3. Create indexes on all tables

### 5.9. Application Responsibilities
The following are NOT handled at database level:
- User authentication and password hashing (Symfony Security)
- Timestamp management (Doctrine lifecycle callbacks)
- Component template definitions
- Default page layouts for new users
- JSONB structure validation
- Theme settings schema validation
- Initial shop/page creation on registration
- Image URL format validation
- Demo data seeding

### 5.10. Future Considerations
- JSON storage allows adding new component types without schema changes
- Shop-centric model can support multi-shop per user in future
- Can add media library table later without breaking image URL references
- Can introduce audit/versioning tables as separate layer
- Can add full-text search indexes when needed
